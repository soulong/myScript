---
title: "cellprofiler analysis"
format: html
editor_options: 
  chunk_output_type: console
---

#---------------------------------
# prepare data

## load packages
```{r}
rstudioapi::getActiveDocumentContext()$path |>
  dirname() |>
  setwd()
# setwd("/media/hao/Data/2024-05-01_RTKs_active_mutations")

# load packages
library(tidyverse)
library(cowplot)
library(writexl)

# load helper function
c("read_sqlite.R", 
  "read_plate_info.R", 
  "cp_analysis_func.R", 
  "ggplot_helper.R") %>% 
  file.path("/home/hao/Documents/GitHub/myScript/R_functions", .) %>% 
  walk(source)
```

## read cellprofiler db
```{r}
raw <- read_sqlite(
  "cp_result.db", 
  remove_object_prefix=T,
  subset_areashape_category=c("AreaShape_Area", "_Eccentricity", "_EquivalentDiameter",
                              "_Compactness", "_FormFactor", "_Solidity"),
  subset_intenstiy_category=NULL)
```

## define magnification
```{r}
metadata_file <- "metadata.txt"

if(file.exists(metadata_file)) {
  print("extact length per pixel from metadata file")
  length_per_pixel <- read_lines(metadata_file) %>% 
    str_subset("Axis X Resolution per Pixel") %>% 
    first() %>% str_squish() %>% 
    str_replace_all("Axis X Resolution per Pixel: ","") %>% 
    as.numeric() %>% round(4)
} else {
  magification <- "20x"
  image_width <- 1024
  objective_view <- c("100x" = 133, "60x" = 221, "20x" = 655)
  length_per_pixel <- objective_view[magification] * (1/image_width) %>% round(4)
}
# unit: um
print(str_glue("per pixel length: {length_per_pixel} uM"))
```

## metadata plate info
```{r}
plate_info_f <- "plate_info.xlsx"

if(file.exists(plate_info_f)) {
  plate_info <- plate_info_f %>%
    map_dfr(read_plate_info_1) %>%
    # mutate(Metadata_conc=factor(as.numeric(Metadata_conc)))
    # rename(Metadata_gene=value)
    # separate_wider_delim(value, delim = "#",
    #                      names = c("Metadata_name", "Metadata_conc"),
    #                      too_few = "align_start",
    #                      cols_remove = T) %>%
    # separate_wider_delim(value, delim = regex("[+ ]"),
    #                      names = c("Metadata_vector", "Metadata_type", "Metadata_adaptor"),
    #                      too_few = "align_start",
    #                      cols_remove = T) %>%
    # mutate(Metadata_vector=fct_relevel(Metadata_vector, "bln"),
    #        Metadata_reporter=fct_relevel(Metadata_reporter, "ctrl"))
    # rename(Metadata_prefix = Metadata_sheet) %>% 
    # mutate(Metadata_conc=as.numeric(Metadata_conc))
    glimpse()
}
```

## metadata compound
```{r}
# cmpd_lib_name <- c("kinase_inhibitor")
cmpd_lib_name <- NULL

if(!is.null(cmpd_lib_name)) {
  cmpd_lib <- 
    "/media/hao/Data1/compound_screen/cmpd_library/shulab_cmpd_library_merged.csv" %>% 
    read_csv() %>% #pull(library) %>% unique()
    filter(library %in% cmpd_lib_name) %>% 
    select(plate, well, id, name) %>% 
    rename_with(\(x) str_c("Metadata_",x), everything()) %>% 
    glimpse()
  # add plate prefix for imaging data pre-processing
  print(unique(raw$image$Metadata_prefix))
  plate_match <- tibble(
    Metadata_plate=unique(cmpd_lib$Metadata_plate),
    Metadata_prefix=c(1:13) %>% as.character()
      # str_c("ZQ375_plate00", str_pad(1:13, 2, "left", pad="0")), 
    )
  # print(plate_match)
  cmpd_lib <- right_join(plate_match, cmpd_lib, relationship="many-to-many")
  
  # ## add ctrl wells ----------------------------
  # ctrl_wells <- tibble(
  #   Metadata_well=c(str_c(LETTERS[2:15], 2)),
  #   Metadata_id=rep("DMSO", 14),
  #   Metadata_name=rep("DMSO", 14) ) %>% 
  #   expand_grid(
  #     distinct(cmpd_lib[, c("Metadata_plate","Metadata_prefix")]), 
  #     .)
  # print(distinct(ctrl_wells, Metadata_well, .keep_all=T))
  # 
  # cmpd_lib <- bind_rows(cmpd_lib, ctrl_wells)
  
  glimpse(cmpd_lib)
}
```

## metadata position
```{r}
if(!exists("plate_info") & !exists("cmpd_lib")) {
  position_meta <- read_csv("position_metadata.csv") %>% 
    # some rows were skipped cause incorrect focus
    filter(!is.na(`P Index`)) %>% 
    filter(`P Index` != "P Index") %>% 
    mutate(`P Index` = as.integer(`P Index`)) %>% 
    select(Metadata_prefix = prefix, 
           Metadata_position = `P Index`,
           Metadata_position_name = `Position Name`)
  
  if(is.na(position_meta$Metadata_position_name[1])) {
    # you should edit position data here if no position name
    print("no position name found, should edit it here")
    
    position_meta <- position_meta %>%
      mutate(Metadata_group = case_when(
        Metadata_prefix == "60XBEAS2B-V1&V3+GRB2-MIFP" & Metadata_position %in% 1:20 ~ "V1+GRB2",
        Metadata_prefix == "60XBEAS2B-V1&V3+GRB2-MIFP" & Metadata_position %in% 21:60 ~ "V3+GRB2",
        Metadata_prefix == "60XBEAS2B-V1&V3" & Metadata_position %in% 1:10 ~ "V1",
        Metadata_prefix == "60XBEAS2B-V1&V3" & Metadata_position %in% 11:20 ~ "V3"
        )) %>% 
      distinct(.keep_all = T) %>%
      mutate(
        Metadata_field = row_number(),
        Metadata_position_name = NULL,
        .by = c(Metadata_prefix, Metadata_group))
  }
  glimpse(position_meta)
}
```

## tidy image
```{r}
image <- raw$image %>% 
  select(!c(starts_with("Image_Count_"),
            matches("Image_Intensity_Percentile_[25]_.*"))) %>% 
  rename_with(\(x) str_replace(x, "Intensity_Percentile_1", "bg"))
glimpse(image)

## get metadata from image prefix
if(F) {
  image <- image %>%
    # mutate(Metadata_sheet=Metadata_prefix)
  separate_wider_delim(
    Metadata_prefix, delim = "-",
    names = c("Metadata_sheet", "Metadata_id"),
    too_few = "align_start", too_many = "drop", cols_remove = F)
  # mutate(Metadata_sheet=str_replace_all(Metadata_sheet, "20X-","") %>%
  #          str_to_lower())
}

## merge with metadata
if(exists("plate_info")) {
  print("merge with plate_info")
  image <- left_join(image, plate_info) } # , by=join_by(Metadata_sheet, Metadata_well)
if(exists("cmpd_lib")) {
  print("merge with cmpd_lib")
  image <- left_join(image, cmpd_lib) } # , by=join_by(Metadata_prefix, Metadata_well)
if(exists("position_meta")) {
  print("merge with position_meta")
  image <- left_join(image, position_meta) } # , by=join_by(Metadata_prefix, Metadata_position)

## remove unwanted metadata columns
image <- image %>% 
  select(!c(Metadata_directory, Metadata_stack, Metadata_position)) %>% 
  { if(length(unique(image[["Metadata_timepoint"]]))==1 ) {
    select(., !Metadata_timepoint) } else .} %>% 
  select(starts_with("Metadata"), everything())

glimpse(image)
# count(image, Metadata_prefix, Metadata_barcode, Metadata_well) %>% view
```

## tidy cell
```{r}
# glimpse(raw$objects)
cell_obj <- str_subset(names(raw$objects), "^cell") %>% print()
if(length(cell_obj) > 0) {
  # cell <- raw$objects %>% bind_row(.id="Metadata_object") %>% 
  cell <- raw$objects[[cell_obj]] %>% 
    dplyr::select(!any_of(c(#"Number_Object_Number",
      "Parent_mask_cp_masks_cell",
      "Parent_ConvertImageObjects",
      "Parent_FilterObjects"))) %>% #glimpse()
    right_join(
      dplyr::select(image, starts_with("Metadata"), ImageNumber), ., 
      by=join_by(ImageNumber)) %>% 
    dplyr::rename(AreaShape_AreaPixel=AreaShape_Area) %>%
    # scale pixel to actual length
    {if(!is.null(length_per_pixel)) {
      mutate(., across(matches("*(Diameter)|(AxisLength)|(Radius)|(Perimeter)$"),
                       \(x) x * length_per_pixel)) %>% 
        mutate(across(ends_with("_Area"), \(x) x * (length_per_pixel)^2))
    } else .} %>% 
    # rename spot-joining column name
    dplyr::rename(cellNumber=Number_Object_Number) %>% 
    # rename probabilities to make plot okay
    rename_with(\(x) str_replace(x, "_Probabilities", "Prob"), 
                !starts_with("Metadata")) %>% 
    glimpse()
  rm(cell_obj)
}
```

<!-- ## add trainSet -->
<!-- ```{r} -->
<!-- trainSet <- read_csv("MyTrainingSet.csv") %>%  -->
<!--   select(ImageNumber, cellNumber=cell_Number_Object_Number, Class) -->

<!-- cell <- cell %>%  -->
<!--   left_join(trainSet) -->
<!-- ``` -->

## subtract background
```{r}
# get all objects
all_objects <- c("image", "cell", "spot", "cellRegion") %>% 
  .[map_lgl(., exists)]

if(F) {
  # group by prefix or not
  subtract_bg_by_prefix <- T
  
  # get all channel names
  bg_channels <- colnames(image) %>% 
    str_subset("ratio", negate = T) %>% 
    str_subset("Image_bg") %>% 
    str_replace_all("Image_bg_", "")
  
  # get bg values
  if(subtract_bg_by_prefix) {
    # by using mean measurement value from each plate
    bg_intensity <- image %>% 
      select(any_of(c("Metadata_prefix", 
                      str_subset(colnames(image), "Image_bg")))) %>% 
      select(!matches(".*ratio")) %>% 
      rename_with(~ str_c(.x, "_mean_by_prefix"), !Metadata_prefix) %>%
      reframe(across(everything(), 
                     ~ median(.x, na.rm=T) %>% round(4)),
              .by=Metadata_prefix)
  } else {
    # by using a single mean value from total bg image measurement
    bg_intensity <- image %>% 
      select(any_of(str_subset(colnames(image), "Image_bg"))) %>% 
      select(!matches(".*ratio")) %>% 
      rename_with(~ str_c(.x, "_mean_by_prefix"), everything()) %>%
      reframe(across(everything(), 
                     ~ median(.x, na.rm=T) %>% round()) ) %>% 
      expand_grid(tibble(
        Metadata_prefix=unique(image$Metadata_prefix)), .)
  }
  glimpse(bg_intensity)
  
  # or by manual defined
  if(F) {
    bg_intensity <- c(
      "Image_bg_ch1_mean_by_prefix" = 1570,
      "Image_bg_ch2_mean_by_prefix" = 1565,
      "Image_bg_ch3_mean_by_prefix" = 1577) %>%
      enframe() %>%
      pivot_wider(names_from = name, values_from = value) %>%
      expand_grid(tibble(Metadata_prefix=unique(image$Metadata_prefix)))
  }
  
  # prepare merged data
  for(obj in all_objects) {
    obj_df <- get(obj)
    obj_df <- left_join(obj_df, bg_intensity, by = join_by(Metadata_prefix))
    assign(obj, obj_df)
    rm(obj_df) }
  
  # process one channel each time
  for(ch in bg_channels) {
    for(obj in all_objects) {
      obj_df <- get(obj)
      # MeanIntensity
      if(str_glue("Intensity_MeanIntensity_{ch}") %in% colnames(obj_df)) {
        obj_df[[str_glue("Intensity_MeanIntensity_{ch}")]] <- 
          (obj_df[[str_glue("Intensity_MeanIntensity_{ch}")]] - 
             obj_df[[str_glue("Image_bg_{ch}_mean_by_prefix")]]) }
      # IntegratedIntensity
      if(str_glue("Intensity_IntegratedIntensity_{ch}") %in% colnames(obj_df)) {
        obj_df[[str_glue("Intensity_IntegratedIntensity_{ch}")]] <- 
          (obj_df[[str_glue("Intensity_IntegratedIntensity_{ch}")]] - 
             obj_df[[str_glue("Image_bg_{ch}_mean_by_prefix")]] * 
             obj_df[[str_glue("AreaShape_Pixel")]]) }
      # remove bg column
      obj_df[[str_glue("Image_bg_{ch}_mean_by_prefix")]] <- NULL
      # assign data
      assign(obj, obj_df)
      rm(obj_df)
    }
  }
  
  # glimpse(image)
  # glimpse(cell)
}
```


#---------------------------------
# decorate data

## change channel names
```{r}
# for training model, must not change name here !!!
channel_names = c("BFP"="ch1", "GFP"="ch2", "RFP"="ch3", "IFP"="ch4")
# channel_names = NULL

if(!is.null(channel_names)) {
  for(obj in all_objects) {
    print(str_glue("change name for {obj}"))
    obj_df <- get(obj)
    # change channel name
    for(idx in seq_along(channel_names)) {
      obj_df <- obj_df %>% 
        rename_with(\(x) str_replace(x, str_c("_", channel_names[idx]), 
                                     str_c("_", names(channel_names)[idx])),
                    !starts_with("Metadata")) %>% glimpse }
    # assign data
    assign(obj, obj_df)
    rm(obj_df)
  }
}

glimpse(image)
glimpse(cell)
```

## modify object
```{r}
# make sure each combination have value, 
# if not existed, fill with 0
if(F) {
  uni_combination <- image %>% 
    # select(any_of(c("Metadata_prefix", "Metadata_reporter", 
    #                 "Metadata_well", "Metadata_field",
    #                 "Metadata_name"))) %>% 
    select(starts_with("Metadata_"), ImageNumber) %>% 
    distinct() %>% 
    glimpse()
  
  cell <- cell %>% 
    left_join(uni_combination, .) %>%
    mutate(across(!starts_with("Metadata"), ~ replace_na(.x, 0))) %>% 
    glimpse()
}


# filter object
if(T) {
  cell_train <- cell %>% 
    filter(str_detect(Metadata_cell, "^BC[0-9]")) %>% 
    select(Class=Metadata_cell,
           matches("Intensity_.*_(BFP)|(IFP)"),
           matches("Texture_.*_(BFP)|(IFP)"),
           matches("RadialDistribution_.*_(BFP)|(IFP)"),
           matches("Correlation_.*")) %>% 
    filter(!is.na(Class)) %>%
    mutate(Class=as.factor(Class)) %>%
    glimpse()
  
  cell_mixed <- cell %>%
    filter(str_detect(Metadata_cell, "^Mix"))
}

```


#---------------------------------
# tidymodel
```{r}
library(tidymodels)
set.seed(42)

count(cell_train, Class)

data_split <- cell_train %>%
  slice_sample(n = 30000, replace = F, by = Class) %>% #count(Class)
  # initial_validation_split(prop = c(0.6, 0.2), strata = Class) %>% 
  initial_split(prop=0.75)

# data_train_val <- validation_set(data_split)
# data_test <- testing(data_split)
```

## fit wf
```{r}
## prepare recipe
recipe <- recipe(Class ~ ., data=training(data_split)) %>%
  step_nzv(all_predictors()) %>%
  step_normalize(all_predictors(), -all_nominal_predictors())
# bake(recipe, new_data=data_test)

## set metric
eval_metrics <- metric_set(roc_auc, accuracy, recall, precision, f_meas)

## set model
# random forest
if(T) {
  require(ranger)
  model <- rand_forest(
    # mtry = tune(),
    # min_n = tune(),
  ) %>%
    set_mode("classification") %>%
    set_engine("ranger", num.threads=40, importance="permutation", seed=42) 
}

# lightGBM
if(F) {
  require(lightgbm)
  require(bonsai)
  model <- boost_tree(
    # mtry = tune(),
    # trees = tune(),
    # min_n = tune(),
    # tree_depth = tune(),
    # learn_rate = tune(),
    # loss_reduction = tune()
    ) %>%
    set_mode("classification") %>%
    set_engine("lightgbm", num.threads=40, seed=42)
  }


## prepare workflow
wf <- workflow() %>%
  add_recipe(recipe) %>%
  add_model(model)
print(wf)

## fit workflow
wf_lastfit <- wf %>% last_fit(
  data_split, metrics = eval_metrics, add_validation_set = T)
```


## tune wf
```{r}
if(F) {
  ## fit tune
  library(future)
  plan(multisession, workers = 40)
  # plan(sequential)
  plan()
  
  wf_tune <- wf %>% 
    update_model(rand_forest(
      mtry = tune(),
      min_n = tune()
    ))
  
  grid_dial <- wf_tune %>% 
    extract_parameter_set_dials() %>% 
    finalize(data_train) %>% 
    # grid_regular(levels = 3) %>%
    grid_random(size = 20) %>%
    {.}
  
  # fit
  wf_tune_fit <- wf_tune %>% 
    tune_grid(
      data_train_vfold,
      grid = grid_dial,
      metrics = eval_metrics,
      control = control_resamples(save_pred = TRUE))
  
  # get best tune values
  rf <- show_best(wf_tune_fit, metric = "f_meas")
  wf_fit_tune_best <- wf_tune_fit %>% 
    select_best(metric = "f_meas")
  
  # check metrics
  wf_tune_fit %>% 
    collect_metrics()
  
  wf_tune_fit %>% 
    collect_predictions(parameters = best_tune) %>% 
    roc_curve(Class, .pred_class) 
  
  best_fit
  
  # last fit
  wf_lastfit <- wf_tune_fit_best %>% last_fit(
    data_split, metrics = eval_metrics, add_validation_set = T)
}
```

## model metric
```{r}
# metrics
metric <- collect_metrics(wf_lastfit)
print(metric)
write_csv(metric, str_glue("{Sys.Date()}_barcode_model_metric.csv"))

# confusion matrix
collect_predictions(wf_lastfit) %>% 
  conf_mat(Class, .pred_class) %>% 
  autoplot(type = "heatmap")
ggsave2(str_glue("{Sys.Date()}_barcode_model_confmat.pdf"),
        width=6, height=6)

# ROC curve
collect_predictions(wf_lastfit) %>% 
  roc_curve(Class, setdiff(starts_with(".pred_"), contains(".pred_class"))) %>% 
  autoplot() +
  theme(strip.background=element_rect(fill=NA))
ggsave2(str_glue("{Sys.Date()}_barcode_model_roc_curve.pdf"),
        width=6, height=6)
```

## feature importance
```{r}
## use model derived importance
library(vip)
wf_lastfit %>%
  extract_fit_engine() %>%
  vip(num_features = 50) +
  theme_bw()
ggsave2(str_glue("{Sys.Date()}_barcode_model_feature_vip.pdf"),
        width=7, height=10)


# ## use shap value
# library(DALEXtra)
# 
# X <- training(data_split)[1:20, ]
# Y <- as.numeric(X[["Class"]])
# 
# pf <- function(m, X) {
#   predict(m, X, type = "class")$.pred_class
# }
# 
# explain_shape <- DALEX::explain(
#   wf_lastfit %>% extract_workflow(), 
#   data = X,
#   y = Y,
#   predict_function = pf
# )

# # or use DALEXtra directly
# explain_shape <- DALEXtra::explain_tidymodels(
#    wf_lastfit, 
#   data = X,
#   y = Y
# )

# check importance
# not work now, will be stuck ...
# DALEX::feature_importance(explain_shape)

```

## make new prediction
```{r}
# predict mix well cells
barcode_prediction <- wf_lastfit %>% 
  extract_workflow() %>% 
  augment(cell, type="prob")
barcode_prediction <- barcode_prediction %>%
  rename_with(~ str_c("Metadata_model_", str_replace(.x, ".pred_", "prob_")), 
              starts_with(".pred_")) %>%
  rename(Metadata_model_class=Metadata_model_prob_class)

count(cell, Metadata_cell)
count(barcode_prediction, Metadata_model_class)

library(tidyplots)
# prob distribution
p1 <- barcode_prediction %>%
  filter(!str_detect(Metadata_cell, "^Mix")) %>% 
  # slice_sample(n=1000) %>% 
  pivot_longer(starts_with("Metadata_model_prob")) %>% # glimpse()
  # slice_max(value, n=1, by = c(Metadata_prefix, Metadata_well, Metadata_field, cellNumber)) %>%
  ggplot(aes(x=value, color=Metadata_model_class)) +
  geom_density() +
  scale_x_continuous(limits=c(0.6, 1)) +
  facet_wrap(~ Metadata_cell, scales="free", nrow=2) +
  labs(x="", y="Density") +
  theme_classic(base_size=7)
ggsave(str_glue("{Sys.Date()}_barcode_trainset_prob_distribution.pdf"), p1,width=7, height=3)

p2 <- barcode_prediction %>%
  filter(!str_detect(Metadata_cell, "^Mix")) %>% 
  # slice_sample(n=1000) %>% 
  pivot_longer(starts_with("Metadata_model_prob")) %>% # glimpse()
  # slice_max(value, n=1, by = c(Metadata_prefix, Metadata_well, Metadata_field, cellNumber)) %>%
  ggplot(aes(x=value, color=Metadata_model_class)) +
  geom_density() +
  scale_x_continuous(limits=c(0.6, 1)) +
  facet_grid(Metadata_cmpd ~ Metadata_cell, scales="free") +
  labs(x="", y="Density") +
  theme_classic(base_size=7)
ggsave(str_glue("{Sys.Date()}_barcode_trainset_prob_distribution2.pdf"), p2,width=7, height=12)

p3 <- barcode_prediction %>%
  filter(str_detect(Metadata_cell, "^Mix")) %>% 
  # slice_sample(n=1000) %>% 
  pivot_longer(starts_with("Metadata_model_prob")) %>% # glimpse()
  # slice_max(value, n=1, by = c(Metadata_prefix, Metadata_well, Metadata_field, cellNumber)) %>%
  ggplot(aes(x=value, color=Metadata_model_class)) +
  geom_density() +
  scale_x_continuous(limits=c(0.6, 1)) +
  facet_wrap(~ Metadata_cell, scales="free", nrow=3) +
  labs(x="", y="Density") +
  theme_classic(base_size=7)
ggsave(str_glue("{Sys.Date()}_barcode_mix_prob_distribution.pdf"), p3, width=3, height=3)
```

## save model
```{r}
wf_lastfit %>% 
  extract_workflow() %>% 
  write_rds(str_glue("{Sys.Date()}_barcode_model.rds"))
# wf_fit <- read_rds("2024-06-03_barcode_model.rds")
```


## evaluate cmpd
### cal function
```{r}
mean_func <- function(x) mean(x, trim=0, na.rm=T)
sum_func <- function(x) sum(x, na.rm=T)
```

### SURF positive well
```{r}
pos_surf <- barcode_prediction %>% 
  mutate(Intensity_MeanIntensity_GFPRatioRFP=
           Intensity_MeanIntensity_GFP/
           Intensity_MeanIntensity_RFP) %>% 
  filter(str_detect(Metadata_cell, "^BC")) %>% 
  filter(Metadata_cell %in% c("BC100","BC101","BC102","BC110","BC115"))
pos_surf %>% 
  ggplot(aes(Intensity_MeanIntensity_GFP)) +
  geom_density() +
  facet_wrap(~ Metadata_cell) +
  scale_x_log10() +
  coord_cartesian(xlim=c(1600, 3000))

min_prob <- 0 # this is only for known positive wells
mean_rfp_limits <- c(1700, 40000)
pos_surf_norm <- pos_surf %>% 
  select(!contains(c("BFP","IFP"))) %>% 
  # any cell identity require prob > 0.75
  filter(if_any(starts_with("Metadata_model_prob"), ~ .x > min_prob)) %>% 
  filter(between(Intensity_MeanIntensity_RFP, mean_rfp_limits[1], mean_rfp_limits[2])) %>% 
  summarize_to_field(
    grouping_vars=c("Metadata_cell","Metadata_cmpd","Metadata_well"),
    mean_func, sum_func) %>%
  normalize_data(
    ctrl_colname="Metadata_cmpd", ctrl_value="DMSO",
    grouping_vars=c("Metadata_cell"), 
    use_median=F, mean_trim=0, const=0) %>%
  # summarize_mean_sd(
  #   grouping_vars=c("Metadata_cell","Metadata_cmpd"), mean_trim=0) %>% 
  glimpse()

p1 <- pos_surf_norm %>% 
  ggplot(aes(Metadata_cmpd, 
             # mean_intensity_RFP
             mean_intensity_GFPRatioRFP,
             # Intensity_MeanIntensity_RFP, 
             # Intensity_MeanIntensity_GFPRatioRFP
             fill=Metadata_cell)) +
  geom_boxplot(outliers=F, show.legend=F) +
  # ggbeeswarm::geom_beeswarm() +
  facet_wrap(~ Metadata_cell, axes="all") +
  my_theme(angle=0)
```

### SURF mixed well
```{r}
mix_surf <- barcode_prediction %>% 
  mutate(Intensity_MeanIntensity_GFPRatioRFP=
           Intensity_MeanIntensity_GFP/
           Intensity_MeanIntensity_RFP) %>% 
  filter(str_detect(Metadata_reporter, "^Merge")) %>% 
  filter(Metadata_model_class %in% c("BC100","BC101","BC102","BC110","BC115"))

min_prob <- 0.8
mean_rfp_limits <- c(1800, 40000)
mix_surf_norm <- mix_surf %>% 
  select(!contains(c("BFP","IFP"))) %>% 
  # any cell identity require prob > 0.75
  filter(if_any(starts_with("Metadata_model_prob"), ~ .x > min_prob)) %>% 
  filter(between(Intensity_MeanIntensity_RFP, mean_rfp_limits[1], mean_rfp_limits[2])) %>% 
  summarize_to_field(
    grouping_vars=c("Metadata_model_class","Metadata_cmpd","Metadata_well"),
    mean_func, sum_func) %>%
  normalize_data(
    ctrl_colname="Metadata_cmpd", ctrl_value="DMSO",
    grouping_vars=c("Metadata_model_class"), 
    use_median=F, mean_trim=0, const=0) %>%
  # summarize_mean_sd(
  #   grouping_vars=c("Metadata_cell","Metadata_cmpd"), mean_trim=0) %>% 
  glimpse()

p2 <- mix_surf_norm %>% 
  ggplot(aes(Metadata_cmpd, 
             # mean_intensity_RFP
             mean_intensity_GFPRatioRFP,
             # Intensity_MeanIntensity_RFP, 
             # Intensity_MeanIntensity_GFPRatioRFP
             fill=Metadata_model_class)) +
  geom_boxplot(outliers=F, show.legend=F) +
  # ggbeeswarm::geom_beeswarm() +
  facet_wrap(~ Metadata_model_class, axes="all") +
  my_theme(angle=0)
```


### tdT positive well
```{r}
pos_tdT <- barcode_prediction %>% 
  mutate(Intensity_MeanIntensity_RFPRatioGFP=
           Intensity_MeanIntensity_RFP/
           Intensity_MeanIntensity_GFP) %>% 
  filter(str_detect(Metadata_cell, "^BC")) %>% 
  filter(Metadata_cell %in% c("BC103","BC104","BC105"))

min_prob <- 0 # this is only for known positive wells
mean_gfp_limits <- c(1700, 65000)
pos_tdT_norm <- pos_tdT %>% 
  select(!contains(c("BFP","IFP"))) %>% 
  # any cell identity require prob > 0.75
  filter(if_any(starts_with("Metadata_model_prob"), ~ .x > min_prob)) %>% 
  filter(between(Intensity_MeanIntensity_GFP, mean_gfp_limits[1], mean_gfp_limits[2])) %>% 
  summarize_to_field(
    grouping_vars=c("Metadata_cell","Metadata_cmpd","Metadata_well"),
    mean_func, sum_func) %>%
  normalize_data(
    ctrl_colname="Metadata_cmpd", ctrl_value="DMSO",
    grouping_vars=c("Metadata_cell"), 
    use_median=F, mean_trim=0, const=0) %>%
  # summarize_mean_sd(
  #   grouping_vars=c("Metadata_cell","Metadata_cmpd"), mean_trim=0) %>% 
  glimpse()

p3 <- pos_tdT_norm %>% 
  ggplot(aes(Metadata_cmpd, 
             # mean_intensity_RFP
             mean_intensity_RFPRatioGFP,
             # Intensity_MeanIntensity_RFP, 
             # Intensity_MeanIntensity_GFPRatioRFP
             fill=Metadata_cell)) +
  geom_boxplot(outliers=F, show.legend=F) +
  # ggbeeswarm::geom_beeswarm() +
  facet_wrap(~ Metadata_cell, axes="all") +
  my_theme(angle=0)
```

### tdT mixed well
```{r}
mix_tdT <- barcode_prediction %>% 
  mutate(Intensity_MeanIntensity_RFPRatioGFP=
           Intensity_MeanIntensity_RFP/
           Intensity_MeanIntensity_GFP) %>% 
    filter(str_detect(Metadata_reporter, "^Merge")) %>% 
  filter(Metadata_model_class %in% c("BC103","BC104","BC105"))

min_prob <- 0.8 # this is only for known positive wells
mean_gfp_limits <- c(1700, 65000)
mix_tdT_norm <- mix_tdT %>% 
  select(!contains(c("BFP","IFP"))) %>% 
  # any cell identity require prob > 0.75
  filter(if_any(starts_with("Metadata_model_prob"), ~ .x > min_prob)) %>% 
  filter(between(Intensity_MeanIntensity_GFP, mean_gfp_limits[1], mean_gfp_limits[2])) %>% 
  # filter(between(Intensity_MeanIntensity_RFP, mean_rfp_limits[1], mean_rfp_limits[2])) %>% 
  summarize_to_field(
    grouping_vars=c("Metadata_model_class","Metadata_cmpd","Metadata_well"),
    mean_func, sum_func) %>%
  normalize_data(
    ctrl_colname="Metadata_cmpd", ctrl_value="DMSO",
    grouping_vars=c("Metadata_model_class"), 
    use_median=F, mean_trim=0, const=0) %>%
  # summarize_mean_sd(
  #   grouping_vars=c("Metadata_cell","Metadata_cmpd"), mean_trim=0) %>% 
  glimpse()

p4 <- mix_tdT_norm %>% 
  ggplot(aes(Metadata_cmpd, 
             # mean_intensity_RFP
             mean_intensity_RFPRatioGFP,
             # Intensity_MeanIntensity_RFP, 
             # Intensity_MeanIntensity_GFPRatioRFP
             fill=Metadata_model_class)) +
  geom_boxplot(outliers=F, show.legend=F) +
  # ggbeeswarm::geom_beeswarm() +
  facet_wrap(~ Metadata_model_class, axes="all") +
  my_theme(angle=0)
```


## feature PCA
```{r}
pdata <- cell %>% 
  # filter(str_detect(Metadata_cell, "^BC[0-9]")) %>% 
  select(starts_with("Metadata"),
         matches("Intensity_.*_(BFP)|(IFP)"),
         matches("Texture_.*_(BFP)|(IFP)"),
         matches("RadialDistribution_.*_(BFP)|(IFP)"),
         matches("Correlation_.*")) %>% 
  mutate(Metadata_train=ifelse(str_detect(Metadata_cell, "BC"), "train", "mix")) %>% 
  filter(str_detect(Metadata_cell, "^BC[0-9]")) %>% 
  filter(Metadata_cmpd == "DMSO") %>% 
  glimpse()

# run pca
pca <- pdata %>% 
  select(!starts_with("Metadata")) %>% 
  prcomp(scale.=T, center=T)

# plot pca
library(factoextra)
fviz_pca_ind(pca, col.ind=pdata$Metadata_cell)
```

## feature UMAP
```{r}
library(uwot)

# run umap
umap <- pca$x %>% 
  bind_cols(select(pdata, starts_with("Metadata")), 
            as_tibble(umap(., n_neighbors=10, min_dist=0.01)))

# plot umap
umap %>% 
  ggplot(aes(V1, V2, color=Metadata_cell)) +
  ggrastr::geom_point_rast(raster.dpi=150) +
  facet_wrap(~ Metadata_cell, nrow=2) +
  theme_classic()




kabsch <- function(pm, qm) {
  pm_dims <- dim(pm)
  if (!all(dim(qm) == pm_dims)) {
    stop(call. = TRUE, "Point sets must have the same dimensions")
  }
  # The rotation matrix will have (ncol - 1) leading ones in the diagonal
  diag_ones <- rep(1, pm_dims[2] - 1)

  # center the points
  pm <- scale(pm, center = TRUE, scale = FALSE)
  qm <- scale(qm, center = TRUE, scale = FALSE)

  am <- crossprod(pm, qm)

  svd_res <- svd(am)
  # use the sign of the determinant to ensure a right-hand coordinate system
  d <- determinant(tcrossprod(svd_res$v, svd_res$u))$sign
  dm <- diag(c(diag_ones, d))

  # rotation matrix
  um <- svd_res$v %*% tcrossprod(dm, svd_res$u)

  # Rotate and then translate to the original centroid location of qm
  sweep(t(tcrossprod(um, pm)), 2, -attr(qm, "scaled:center"))
}
iris_pca2 <- prcomp(iris[, 1:4])$x[, 1:2]
plot_umap <- function(coords, col = iris$Species, pca = iris_pca2) {
  plot(kabsch(coords, pca), col = col, xlab = "", ylab = "")
}

iris_umap <- umap(iris)
plot_umap(iris_umap)

```

